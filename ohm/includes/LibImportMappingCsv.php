<?php

namespace OHM\Includes;

use RuntimeException;

/**
 * This class represents a single CSV file containing questionset ID
 * mappings and is used by admin/importlib.php.
 */
class LibImportMappingCsv
{
    /*
     * This constant is used for:
     * - Writing CSV headers to the QID mapping CSV file generated by this page.
     * - By _getFeedbackMacroCsvColumnValues() to:
     *   - Find macro names in question code.
     *   - Return properly marked CSV columns.
     *
     * This list must be ordered as they are expected to appear in the CSV File.
     */
    const TRANSLATED_OHM_MACRO_NAMES = [
        'getfeedbackbasic',
        'getfeedbacktxt',
        'getfeedbacktxtessay',
        'getfeedbacktxtnumber',
        'getfeedbacktxtnumfunc',
        'getfeedbacktxtcalculated',
        'getfeedbacktxtmultans',
    ];

    // This is used for building the full filesystem path to the CSV
    // file and the web browser URL prefix.
    const CSV_DOCUMENT_ROOT_PREFIX = '/filestore'; // No trailing slash!

    private $csvFileHandle = false;

    /*
     * These will be set in __construct() and should not be changed.
     * PHP 8.4 can let these be final! \o/
     */

    // This contains the values in TRANSLATED_OHM_MACRO_NAMES but with "\s*("
    // appended to each value.
    private $translatedOhmMacroNamesForRegex;

    // Just the filename portion.
    private $csvFilename;

    private $csvDownloadUrl;
    private $csvFilesystemPath;

    public function __construct()
    {
        // Format macro names for use in a regex.
        $this->translatedOhmMacroNamesForRegex = array_map(function ($name): string {
            return $name . '\s*\('; // Spaces between function names and "(" are valid PHP.
        }, self::TRANSLATED_OHM_MACRO_NAMES);

        $timeStr = strftime('%Y-%m-%d_%H-%M-%S', time());
        $this->csvFilename = 'qid_mapping_' . $timeStr . '.csv';

        $this->csvDownloadUrl = self::CSV_DOCUMENT_ROOT_PREFIX . '/' . $this->csvFilename;
        $this->csvFilesystemPath = $GLOBALS['_SERVER']['DOCUMENT_ROOT']
            . self::CSV_DOCUMENT_ROOT_PREFIX . '/' . $this->csvFilename;
    }

    /**
     * Get the download URL for the CSV file.
     *
     * This only includes the URL portion beginning after the first "/".
     * Example: "/filestore/qid_mapping_1741632444562.csv"
     *
     * Note: This CSV file may not exist yet if it hasn't been created
     * with open().
     *
     * @return string
     */
    public function getDownloadUrl(): string
    {
        return $this->csvDownloadUrl;
    }

    /**
     * Get the full filesystem path to the CSV file.
     *
     * Note: This CSV file may not exist yet if it hasn't been created
     * with open().
     *
     * @return string
     */
    public function getFilesystemPath(): string
    {
        return $this->csvFilesystemPath;
    }

    /**
     * Determine if the CSV file is currently open.
     *
     * @return bool True if the file is open. False if not.
     */
    public function isOpen(): bool
    {
        return false !== $this->csvFileHandle;
    }

    /**
     * Close the CSV file, if it's open.
     *
     * @return void
     */
    public function close(): void
    {
        if ($this->isOpen()) {
            fclose($this->csvFileHandle);
        }
        $this->csvFileHandle = false;
    }

    /**
     * Create and open the CSV file.
     *
     * @return void
     * @throws RuntimeException Thrown on errors while opening the CSV file.
     */
    public function open(): void
    {
        if ($this->isOpen()) {
            throw new RuntimeException('CSV file is already open.');
        }

        $this->csvFileHandle = fopen($this->csvFilesystemPath, "wb");

        if (!$this->csvFileHandle) {
            $message = error_get_last()['message'];
            throw new RuntimeException($message);
        } else {
            // Write the CSV header.
            $qidMappingCsvHeader = array_merge(
                [
                    'ohm1_qid',
                    'ohm2_qid',
                    'question_type',
                ],
                self::TRANSLATED_OHM_MACRO_NAMES,
            );
            // The third argument here is required in PHP 8.4. Do not remove.
            fputcsv($this->csvFileHandle, $qidMappingCsvHeader, ',');
        }
    }

    /**
     * Add a row to the CSV file of QID mappings.
     *
     * @param string $questionControl A question's code. (imas_questionset.control)
     * @param int $sourceQid The original imas_questionset.id value from the source OHM DB before export.
     * @param int $targetQid The current imas_questionset.id value from in target OHM DB on import.
     * @param string $questionType The question's type. (imas_questionset.qtype)
     * @return bool True if a row was written. False if not.
     */
    public function addQidMappingRowToCsv(string $questionControl,
                                          int    $sourceQid,
                                          int    $targetQid,
                                          string $questionType): bool
    {
        if (!$this->isOpen()) {
            return false;
        }

        $macroColumnValues = $this->getFeedbackMacroCsvColumnValues($questionControl);

        $csvValues = array_merge(
            [$sourceQid, $targetQid, $questionType],
            $macroColumnValues
        );
        // The third argument here is required in PHP 8.4. Do not remove.
        $lengthWritten = fputcsv($this->csvFileHandle, $csvValues, ",");

        // fputcsv returns int|false, so we just check for a number to see if anything
        // was written to disk. (a 0-length string would indicate a blank line)
        return is_int($lengthWritten);
    }

    /**
     * Get a string array of macro names used in question control.
     *
     * This array of strings ("" or "x") will be ordered for insertion into the
     * QID mapping CSV file created by this page.
     *
     * @param string $questionControl A question's code. (imas_questionset.control)
     * @return array CSV row values as an array of strings.
     */
    private function getFeedbackMacroCsvColumnValues(string $questionControl): array
    {
        // Initialize an array with empty CSV column values.
        $csvColumnValues = array_fill(0, count(self::TRANSLATED_OHM_MACRO_NAMES), '');

        // Get the names of all macros used in question control.
        $pattern = '/(' . implode('|', $this->translatedOhmMacroNamesForRegex) . ')/';
        preg_match_all($pattern, $questionControl, $matches);

        $foundMacroNames = array_map(function ($name) {
            // We want only the bare macro name, without spaces and "(".
            return preg_replace('/\W*/', '', $name);
        }, $matches[0]);

        // For each macro name found, place an "x" in the correct CSV column.
        foreach ($foundMacroNames as $macroName) {
            $columnIndex = array_search($macroName, self::TRANSLATED_OHM_MACRO_NAMES);
            $csvColumnValues[$columnIndex] = 'x';
        }

        return $csvColumnValues;
    }
}