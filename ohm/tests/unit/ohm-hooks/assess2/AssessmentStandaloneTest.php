<?php

namespace OHM\Tests;

use PHPUnit\Framework\TestCase;


/**
 * Covers OHM hook file: /ohm-hooks/assess2/assess_standalone.php
 *
 * The file under test contains only function definitions.
 * In other words, the tested file has no class.
 */
final class AssessmentStandaloneTest extends TestCase
{
    public static function setUpBeforeClass(): void
    {
        require_once(__DIR__ . '/../../../../../ohm-hooks/assess2/assess_standalone.php');
    }

    /*
     * _removeOhm1Feedback
     */

    public function testRemoveOhm1Feedback_NoOhm1Feedback(): void
    {
        // This contains valid OHM v2 structured feedback.
        $responseData = [
            'scores' => [0.5],
            'raw' => [0.5],
            'errors' => [],
            'allans' => true,
            'feedback' => [
                'qn0' => [
                    'correctness' => 'incorrect',
                    'feedback' => 'A statistical investigative question would require data collection and analysis. Does the question account for variability?  Questions with a single mathematical answer are not considered statistical investigative questions.',
                    'failsafe_data' => [
                        'correct_feedback' => 'Excellent! You are able to distinguish the statstical investigative questions from the rest.',
                    ],
                ],
            ],
        ];

        // This equals $responseData.
        $expectedResponseData = [
            'scores' => [0.5],
            'raw' => [0.5],
            'errors' => [],
            'allans' => true,
            'feedback' => [
                'qn0' => [
                    'correctness' => 'incorrect',
                    'feedback' => 'A statistical investigative question would require data collection and analysis. Does the question account for variability?  Questions with a single mathematical answer are not considered statistical investigative questions.',
                    'failsafe_data' => [
                        'correct_feedback' => 'Excellent! You are able to distinguish the statstical investigative questions from the rest.',
                    ],
                ],
            ],
        ];

        $returnedResponseData = _removeOhm1Feedback($responseData);
        $this->assertEquals($expectedResponseData, $returnedResponseData);
    }

    public function testRemoveOhm1Macros_WithOhm1Feedback(): void
    {
        // This contains feedback generated by OHM 1 macros.
        $responseData = [
            'scores' => [0.5],
            'raw' => [0.5],
            'errors' => [],
            'allans' => true,
            'feedback' => 'Excellent! You are able to distinguish the statstical investigative questions from the rest.',
        ];

        $expectedResponseData = [
            'scores' => [0.5],
            'raw' => [0.5],
            'errors' => [
                'Warning: Feedback may be available but is not being returned due to the usage of OHM1 macros!',
                'Warning: OHM1 feedback = ' . $responseData['feedback'],
            ],
            'allans' => true,
            'feedback' => [],
        ];

        $returnedResponseData = _removeOhm1Feedback($responseData);
        $this->assertEquals($expectedResponseData, $returnedResponseData);
    }

    public function testRemoveOhm1Macros_WithOhm1Feedback_EmptyString(): void
    {
        // In some cases, usage of certain OHM v1 macros in OHM v2 will
        // result in an empty string where feedback should appear.
        $responseData = [
            'scores' => [0.5],
            'raw' => [0.5],
            'errors' => [],
            'allans' => true,
            'feedback' => '',
        ];

        $expectedResponseData = [
            'scores' => [0.5],
            'raw' => [0.5],
            'errors' => [
                'Warning: Feedback may be available but is not being returned due to the usage of OHM1 macros!',
                'Warning: OHM1 feedback is an empty string.',
            ],
            'allans' => true,
            'feedback' => [],
        ];

        $returnedResponseData = _removeOhm1Feedback($responseData);
        $this->assertEquals($expectedResponseData, $returnedResponseData);
    }

    /*
     * _getCorrectAnswersFromScoreResult
     */

    public function testGetCorrectAnswersFromScoreResult_NonMultipart(): void
    {
        /*
         * If question code uses $answer (singular) instead of $answers (plural):
         */

        // This is the value returned by ScoreEngine->scoreResult() after scoring
        // an entire question.
        $scoreResult = [
            'scores' => [1.0],
            'rawScores' => [1.0],
            'lastAnswerAsGiven' => ["0|2"],
            'lastAnswerAsNumber' => [''],
            'correctAnswerWrongFormat' => [false],
            'answeights' => [1],
            'extra' => [
                'answer' => "0,2",
                'answers' => null,
                'anstypes' => null,
                'feedback' => null,
            ],
            'errors' => [],
        ];

        $returnedCorrectAnswers = _getCorrectAnswersFromScoreResult($scoreResult, false);
        $this->assertEquals(['0,2'], $returnedCorrectAnswers);

        /*
         * If question code uses $answers (plural) instead of $answer (singular):
         */

        $scoreResult['extra']['answers'] = $scoreResult['extra']['answer'];
        $scoreResult['extra']['answer'] = null;

        $returnedCorrectAnswers = _getCorrectAnswersFromScoreResult($scoreResult, false);
        $this->assertEquals(['0,2'], $returnedCorrectAnswers);
    }

    public function testGetCorrectAnswersFromScoreResult_Multipart(): void
    {
        /*
         * If question code uses $answer (singular) instead of $answers (plural):
         */

        // This is the value returned by ScoreEngine->scoreResult() after scoring
        // an entire question. (including all its parts)
        $scoreResult = [
            'rawScores' => [1.0, 1.0, 1.0, 1.0],
            'lastAnswerAsGiven' => ["0.972", 0, "0|2", "21.13"],
            'lastAnswerAsNumber' => ['', '', '', ''],
            'correctAnswerWrongFormat' => [false, false, false, false],
            'answeights' => [1, 1, 1, 1],
            'extra' => [
                'answer' => [0.972, 0, "0,2", 21.13],
                'answers' => null,
                'anstypes' => ['number', 'choices', 'multans', 'calculated'],
                'feedback' => null,
            ],
            'scores' => [0.25, 0.25, 0.25, 0.25],
            'errors' => [],
        ];

        $returnedCorrectAnswers = _getCorrectAnswersFromScoreResult($scoreResult, true);
        $this->assertEquals([0.972, 0, '0,2', 21.13], $returnedCorrectAnswers);

        /*
         * If question code uses $answers (plural) instead of $answer (singular):
         */

        $scoreResult['extra']['answers'] = $scoreResult['extra']['answer'];
        $scoreResult['extra']['answer'] = null;

        $returnedCorrectAnswers = _getCorrectAnswersFromScoreResult($scoreResult, true);
        $this->assertEquals([0.972, 0, '0,2', 21.13], $returnedCorrectAnswers);
    }

    /*
     * _shuffleCorrectAnswers
     */

    public function testShuffleCorrectAnswers_NoShuffling(): void
    {
        $unshuffledCorrectAnswers = [2, 5];

        // Defining $shuffledAnswerKeymap this way for visibility.
        // Format: $shuffledAnswerKeymap[ (shuffledKey) ] = (originalKey);
        $shuffledAnswerKeymap = [];
        $shuffledAnswerKeymap[0] = 0;
        $shuffledAnswerKeymap[1] = 1;
        $shuffledAnswerKeymap[2] = 2; // A correct answer. We should see this returned as 2.
        $shuffledAnswerKeymap[3] = 3;
        $shuffledAnswerKeymap[4] = 4;
        $shuffledAnswerKeymap[5] = 5; // A correct answer. We should see this returned as 5.

        $shuffledCorrectAnswers = _shuffleCorrectAnswers($unshuffledCorrectAnswers, $shuffledAnswerKeymap);

        // The student must select answer keys 2 and 5 to be scored correctly.
        $this->assertEquals('2,5', $shuffledCorrectAnswers);
    }

    public function testShuffleCorrectAnswers(): void
    {
        $unshuffledCorrectAnswers = [2, 5];

        // Defining $shuffledAnswerKeymap this way for visibility.
        // Format: $shuffledAnswerKeymap[ (shuffledKey) ] = (originalKey);
        $shuffledAnswerKeymap = [];
        $shuffledAnswerKeymap[0] = 4;
        $shuffledAnswerKeymap[1] = 1;
        $shuffledAnswerKeymap[2] = 3;
        $shuffledAnswerKeymap[3] = 0;
        $shuffledAnswerKeymap[4] = 2; // A correct answer. We should see this returned as 4.
        $shuffledAnswerKeymap[5] = 5; // A correct answer. We should see this returned as 5.

        $shuffledCorrectAnswers = _shuffleCorrectAnswers($unshuffledCorrectAnswers, $shuffledAnswerKeymap);

        // The student must select answer keys 4 and 5 to be scored correctly.
        $this->assertEquals('4,5', $shuffledCorrectAnswers);
    }

    /*
     * _shuffleFeedback
     */

    public function testShuffleFeedback_NoFeedbackAvailable(): void
    {
        $feedback = _shuffleFeedback("0|1|2", [0, 1, 2], []);
        $this->assertEquals([], $feedback);
    }

    public function testShuffleFeedback_NullFeedback(): void
    {
        $feedback = _shuffleFeedback("0|1|2", [1, 0, 2], null);
        $this->assertEquals([], $feedback);
    }

    public function testShuffleFeedback_NoShuffling(): void
    {
        $unshuffledFeedback = [
            'qn0-0' => [
                'correctness' => 'correct',
                'feedback' => '0 - Correct.',
            ],
            'qn0-1' => [
                'correctness' => 'incorrect',
                'feedback' => '1 - Incorrect.',
            ],
            'qn0-2' => [
                'correctness' => 'correct',
                'feedback' => '2 - Correct.',
            ],
            'qn0-3' => [
                'correctness' => 'incorrect',
                'feedback' => '3 - Incorrect.',
            ],
            'qn0-4' => [
                'correctness' => 'incorrect',
                'feedback' => '4 - Incorrect.',
            ],
        ];

        // Defining $answerKeymap this way for visibility.
        // Format: $answerKeymap[ (shuffledKey) ] = (originalKey);
        $answerKeymap = [];
        $answerKeymap[0] = 0; // We should see qn0-0 feedback returned as qn0-0.
        $answerKeymap[1] = 1;
        $answerKeymap[2] = 2; // We should see qn0-2 feedback returned as qn0-2.
        $answerKeymap[3] = 3;
        $answerKeymap[4] = 4; // We should see qn0-4 feedback returned as qn0-4.

        $shuffledFeedback = _shuffleFeedback("0|2|4", $answerKeymap, $unshuffledFeedback);

        // We expect to see feedback for only the answers selected by the student.
        $this->assertCount(3, $shuffledFeedback);

        $this->assertArrayHasKey('qn0-0', $shuffledFeedback);
        $this->assertArrayHasKey('qn0-2', $shuffledFeedback);
        $this->assertArrayHasKey('qn0-4', $shuffledFeedback);

        $this->assertEquals('correct', $shuffledFeedback['qn0-0']['correctness']);
        $this->assertEquals('0 - Correct.', $shuffledFeedback['qn0-0']['feedback']);

        $this->assertEquals('correct', $shuffledFeedback['qn0-2']['correctness']);
        $this->assertEquals('2 - Correct.', $shuffledFeedback['qn0-2']['feedback']);

        $this->assertEquals('incorrect', $shuffledFeedback['qn0-4']['correctness']);
        $this->assertEquals('4 - Incorrect.', $shuffledFeedback['qn0-4']['feedback']);
    }

    public function testShuffleFeedback(): void
    {
        // FIXME: This test should be good but is not passing.
        // FIXME: Likely cause: _shuffleFeedback is not reindexing the "qn1003-NN" keys. (specifically the NN portion)
        // FIXME: For the moment, this is not an issue as OHM 2 does not use answer shuffling.
        // FIXME: This test is being backfilled as part of OHM-1200 but fixing shuffling is out of scope.
        $this->markTestIncomplete('This test is good but does not pass. Fix the the code under test before enabling shuffling in OHM 2 !!');

        $unshuffledFeedback = [
            'qn1003-0' => [
                'correctness' => 'correct',
                'feedback' => '0 - Correct.',
            ],
            'qn1003-1' => [
                'correctness' => 'incorrect',
                'feedback' => '1 - Incorrect.',
            ],
            'qn1003-2' => [
                'correctness' => 'correct',
                'feedback' => '2 - Correct.',
            ],
            'qn1003-3' => [
                'correctness' => 'incorrect',
                'feedback' => '3 - Incorrect.',
            ],
            'qn1003-4' => [
                'correctness' => 'incorrect',
                'feedback' => '4 - Incorrect.',
            ],
        ];

        // Defining $answerKeymap this way for visibility.
        // Format: $answerKeymap[ (shuffledKey) ] = (originalKey);
        $answerKeymap = [];
        $answerKeymap[0] = 2; // We should see qn1003-2 feedback returned as qn1003-0.
        $answerKeymap[1] = 1;
        $answerKeymap[2] = 3; // We should see qn1003-3 feedback returned as qn1003-2.
        $answerKeymap[3] = 0;
        $answerKeymap[4] = 4; // We should see qn1003-4 feedback returned as qn1003-4.

        $shuffledFeedback = _shuffleFeedback("0|2|4", $answerKeymap, $unshuffledFeedback);

        // We expect to see feedback for only the answers selected by the student.
        $this->assertCount(3, $shuffledFeedback);

        $this->assertArrayHasKey('qn1003-0', $shuffledFeedback);
        $this->assertArrayHasKey('qn1003-2', $shuffledFeedback);
        $this->assertArrayHasKey('qn1003-4', $shuffledFeedback);

        $this->assertEquals('correct', $shuffledFeedback['qn1003-0']['correctness']);
        $this->assertEquals('2 - Correct.', $shuffledFeedback['qn1003-0']['feedback']);

        $this->assertEquals('incorrect', $shuffledFeedback['qn1003-2']['correctness']);
        $this->assertEquals('3 - Incorrect.', $shuffledFeedback['qn1003-2']['feedback']);

        $this->assertEquals('incorrect', $shuffledFeedback['qn1003-4']['correctness']);
        $this->assertEquals('4 - Incorrect.', $shuffledFeedback['qn1003-4']['feedback']);
    }

    /*
     * _getFeedbackForPart
     */

    public function testGetFeedbackForPart(): void
    {
        $allFeedbacks = [
            'qn1000' => [
                'correctness' => 'correct',
                'feedback' => 'Correct.',
            ],
            'qn1001' => [
                'correctness' => 'incorrect',
                'feedback' => 'Incorrect.',
            ],
            'qn1002' => [
                'correctness' => 'correct',
                'feedback' => 'Correct.',
            ],
        ];

        $feedback = _getFeedbackForPart($allFeedbacks, 1);

        $this->assertCount(1, $feedback);

        $this->assertEquals('incorrect', $feedback['qn1001']['correctness']);
        $this->assertEquals('Incorrect.', $feedback['qn1001']['feedback']);
    }

    /*
     * _deleteFeedbackByKeys
     */

    public function testDeleteFeedbackByKeys_NoFeedbackAvailable(): void
    {
        $feedbacks = _deleteFeedbackByKeys([], []);
        $this->assertEquals([], $feedbacks);

        $feedbacks = _deleteFeedbackByKeys([], ['qn1000']);
        $this->assertEquals([], $feedbacks);
    }

    public function testDeleteFeedbackByKeys(): void
    {
        $allFeedbacks = [
            'qn1000' => [
                'correctness' => 'correct',
                'feedback' => 'Correct.',
            ],
            'qn1001' => [
                'correctness' => 'incorrect',
                'feedback' => 'Incorrect.',
            ],
            'qn1002' => [
                'correctness' => 'correct',
                'feedback' => 'Correct.',
            ],
        ];

        // Remove no feedback.
        $feedbacks = _deleteFeedbackByKeys($allFeedbacks, []);
        $this->assertCount(3, $feedbacks);
        $this->assertArrayHasKey('qn1000', $feedbacks);
        $this->assertArrayHasKey('qn1001', $feedbacks);
        $this->assertArrayHasKey('qn1002', $feedbacks);
        $this->assertEquals('correct', $feedbacks['qn1000']['correctness']);
        $this->assertEquals('Correct.', $feedbacks['qn1000']['feedback']);
        $this->assertEquals('incorrect', $feedbacks['qn1001']['correctness']);
        $this->assertEquals('Incorrect.', $feedbacks['qn1001']['feedback']);
        $this->assertEquals('correct', $feedbacks['qn1002']['correctness']);
        $this->assertEquals('Correct.', $feedbacks['qn1002']['feedback']);

        // Remove one feedback.
        $feedbacks = _deleteFeedbackByKeys($allFeedbacks, ['qn1001']);
        $this->assertCount(2, $feedbacks);
        $this->assertArrayHasKey('qn1000', $feedbacks);
        $this->assertArrayNotHasKey('qn1001', $feedbacks);
        $this->assertArrayHasKey('qn1002', $feedbacks);
        $this->assertEquals('correct', $feedbacks['qn1000']['correctness']);
        $this->assertEquals('Correct.', $feedbacks['qn1000']['feedback']);
        $this->assertEquals('correct', $feedbacks['qn1002']['correctness']);
        $this->assertEquals('Correct.', $feedbacks['qn1002']['feedback']);

        // Remove two feedbacks.
        $feedbacks = _deleteFeedbackByKeys($allFeedbacks, ['qn1000', 'qn1001']);
        $this->assertCount(1, $feedbacks);
        $this->assertArrayNotHasKey('qn1000', $feedbacks);
        $this->assertArrayNotHasKey('qn1001', $feedbacks);
        $this->assertArrayHasKey('qn1002', $feedbacks);
        $this->assertEquals('correct', $feedbacks['qn1002']['correctness']);
        $this->assertEquals('Correct.', $feedbacks['qn1002']['feedback']);
    }

    /*
     * _correctAnswersAsArray
     */

    public function testCorrectAnswersAsArray(): void
    {
        $answersAsArray = _correctAnswersAsArray("42");
        $this->assertEquals(["42"], $answersAsArray);

        $answersAsArray = _correctAnswersAsArray("1,2,3");
        $this->assertEquals(["1", "2", "3"], $answersAsArray);
    }

    /*
     * _getShuffledKeyByUnseededKey
     */

    public function testGetShuffledKeyByUnseededKey(): void
    {
        // Defining $randomAnswerKeymap this way for visibility.
        // Format: $randomAnswerKeymap[ (shuffledKey) ] = (originalKey);
        $randomAnswerKeymap = [];
        $randomAnswerKeymap[0] = 3;
        $randomAnswerKeymap[1] = 2;
        $randomAnswerKeymap[2] = 0;
        $randomAnswerKeymap[3] = 1;

        $shuffledKey = _getShuffledKeyByUnseededKey(0, $randomAnswerKeymap);
        $this->assertEquals(2, $shuffledKey);

        $shuffledKey = _getShuffledKeyByUnseededKey(1, $randomAnswerKeymap);
        $this->assertEquals(3, $shuffledKey);

        $shuffledKey = _getShuffledKeyByUnseededKey(2, $randomAnswerKeymap);
        $this->assertEquals(1, $shuffledKey);

        $shuffledKey = _getShuffledKeyByUnseededKey(3, $randomAnswerKeymap);
        $this->assertEquals(0, $shuffledKey);
    }
}
